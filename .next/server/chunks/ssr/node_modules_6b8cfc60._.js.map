{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-rsc'\n].ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,4HAAyBC,QAAQ,CACxD,YACD,CAACC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/next/dist/client/script.js/proxy.cjs"],"sourcesContent":["const { createClientModuleProxy } = require(\"react-server-dom-turbopack/server.edge\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/node_modules/next/dist/client/script.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/next/dist/client/script.js/proxy.cjs"],"sourcesContent":["const { createClientModuleProxy } = require(\"react-server-dom-turbopack/server.edge\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/node_modules/next/dist/client/script.js\"));\n"],"names":[],"mappings":"AAAA,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/next/src/client/script.tsx"],"sourcesContent":["'use client'\n\nimport ReactDOM from 'react-dom'\nimport React, { useEffect, useContext, useRef, type JSX } from 'react'\nimport type { ScriptHTMLAttributes } from 'react'\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'\nimport { setAttributesFromProps } from './set-attributes-from-props'\nimport { requestIdleCallback } from './request-idle-callback'\n\nconst ScriptCache = new Map()\nconst LoadCache = new Set()\n\nexport interface ScriptProps extends ScriptHTMLAttributes<HTMLScriptElement> {\n  strategy?: 'afterInteractive' | 'lazyOnload' | 'beforeInteractive' | 'worker'\n  id?: string\n  onLoad?: (e: any) => void\n  onReady?: () => void | null\n  onError?: (e: any) => void\n  children?: React.ReactNode\n  stylesheets?: string[]\n}\n\n/**\n * @deprecated Use `ScriptProps` instead.\n */\nexport type Props = ScriptProps\n\nconst insertStylesheets = (stylesheets: string[]) => {\n  // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n  //\n  // Using ReactDOM.preinit to feature detect appDir and inject styles\n  // Stylesheets might have already been loaded if initialized with Script component\n  // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n  // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n  if (ReactDOM.preinit) {\n    stylesheets.forEach((stylesheet: string) => {\n      ReactDOM.preinit(stylesheet, { as: 'style' })\n    })\n\n    return\n  }\n\n  // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n  //\n  // We use this function to load styles when appdir is not detected\n  // TODO: Use React float APIs to load styles once available for pages dir\n  if (typeof window !== 'undefined') {\n    let head = document.head\n    stylesheets.forEach((stylesheet: string) => {\n      let link = document.createElement('link')\n\n      link.type = 'text/css'\n      link.rel = 'stylesheet'\n      link.href = stylesheet\n\n      head.appendChild(link)\n    })\n  }\n}\n\nconst loadScript = (props: ScriptProps): void => {\n  const {\n    src,\n    id,\n    onLoad = () => {},\n    onReady = null,\n    dangerouslySetInnerHTML,\n    children = '',\n    strategy = 'afterInteractive',\n    onError,\n    stylesheets,\n  } = props\n\n  const cacheKey = id || src\n\n  // Script has already loaded\n  if (cacheKey && LoadCache.has(cacheKey)) {\n    return\n  }\n\n  // Contents of this script are already loading/loaded\n  if (ScriptCache.has(src)) {\n    LoadCache.add(cacheKey)\n    // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n    // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n    ScriptCache.get(src).then(onLoad, onError)\n    return\n  }\n\n  /** Execute after the script first loaded */\n  const afterLoad = () => {\n    // Run onReady for the first time after load event\n    if (onReady) {\n      onReady()\n    }\n    // add cacheKey to LoadCache when load successfully\n    LoadCache.add(cacheKey)\n  }\n\n  const el = document.createElement('script')\n\n  const loadPromise = new Promise<void>((resolve, reject) => {\n    el.addEventListener('load', function (e) {\n      resolve()\n      if (onLoad) {\n        onLoad.call(this, e)\n      }\n      afterLoad()\n    })\n    el.addEventListener('error', function (e) {\n      reject(e)\n    })\n  }).catch(function (e) {\n    if (onError) {\n      onError(e)\n    }\n  })\n\n  if (dangerouslySetInnerHTML) {\n    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n    el.innerHTML = (dangerouslySetInnerHTML.__html as string) || ''\n\n    afterLoad()\n  } else if (children) {\n    el.textContent =\n      typeof children === 'string'\n        ? children\n        : Array.isArray(children)\n          ? children.join('')\n          : ''\n\n    afterLoad()\n  } else if (src) {\n    el.src = src\n    // do not add cacheKey into LoadCache for remote script here\n    // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n\n    ScriptCache.set(src, loadPromise)\n  }\n\n  setAttributesFromProps(el, props)\n\n  if (strategy === 'worker') {\n    el.setAttribute('type', 'text/partytown')\n  }\n\n  el.setAttribute('data-nscript', strategy)\n\n  // Load styles associated with this script\n  if (stylesheets) {\n    insertStylesheets(stylesheets)\n  }\n\n  document.body.appendChild(el)\n}\n\nexport function handleClientScriptLoad(props: ScriptProps) {\n  const { strategy = 'afterInteractive' } = props\n  if (strategy === 'lazyOnload') {\n    window.addEventListener('load', () => {\n      requestIdleCallback(() => loadScript(props))\n    })\n  } else {\n    loadScript(props)\n  }\n}\n\nfunction loadLazyScript(props: ScriptProps) {\n  if (document.readyState === 'complete') {\n    requestIdleCallback(() => loadScript(props))\n  } else {\n    window.addEventListener('load', () => {\n      requestIdleCallback(() => loadScript(props))\n    })\n  }\n}\n\nfunction addBeforeInteractiveToCache() {\n  const scripts = [\n    ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n    ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]'),\n  ]\n  scripts.forEach((script) => {\n    const cacheKey = script.id || script.getAttribute('src')\n    LoadCache.add(cacheKey)\n  })\n}\n\nexport function initScriptLoader(scriptLoaderItems: ScriptProps[]) {\n  scriptLoaderItems.forEach(handleClientScriptLoad)\n  addBeforeInteractiveToCache()\n}\n\n/**\n * Load a third-party scripts in an optimized way.\n *\n * Read more: [Next.js Docs: `next/script`](https://nextjs.org/docs/app/api-reference/components/script)\n */\nfunction Script(props: ScriptProps): JSX.Element | null {\n  const {\n    id,\n    src = '',\n    onLoad = () => {},\n    onReady = null,\n    strategy = 'afterInteractive',\n    onError,\n    stylesheets,\n    ...restProps\n  } = props\n\n  // Context is available only during SSR\n  const { updateScripts, scripts, getIsSsr, appDir, nonce } =\n    useContext(HeadManagerContext)\n\n  /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */\n  const hasOnReadyEffectCalled = useRef(false)\n\n  useEffect(() => {\n    const cacheKey = id || src\n    if (!hasOnReadyEffectCalled.current) {\n      // Run onReady if script has loaded before but component is re-mounted\n      if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n        onReady()\n      }\n\n      hasOnReadyEffectCalled.current = true\n    }\n  }, [onReady, id, src])\n\n  const hasLoadScriptEffectCalled = useRef(false)\n\n  useEffect(() => {\n    if (!hasLoadScriptEffectCalled.current) {\n      if (strategy === 'afterInteractive') {\n        loadScript(props)\n      } else if (strategy === 'lazyOnload') {\n        loadLazyScript(props)\n      }\n\n      hasLoadScriptEffectCalled.current = true\n    }\n  }, [props, strategy])\n\n  if (strategy === 'beforeInteractive' || strategy === 'worker') {\n    if (updateScripts) {\n      scripts[strategy] = (scripts[strategy] || []).concat([\n        {\n          id,\n          src,\n          onLoad,\n          onReady,\n          onError,\n          ...restProps,\n        },\n      ])\n      updateScripts(scripts)\n    } else if (getIsSsr && getIsSsr()) {\n      // Script has already loaded during SSR\n      LoadCache.add(id || src)\n    } else if (getIsSsr && !getIsSsr()) {\n      loadScript(props)\n    }\n  }\n\n  // For the app directory, we need React Float to preload these scripts.\n  if (appDir) {\n    // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n    // For other strategies injecting here ensures correct stylesheet order\n    // ReactDOM.preinit handles loading the styles in the correct order,\n    // also ensures the stylesheet is loaded only once and in a consistent manner\n    //\n    // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n    // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n    // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n    // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n    if (stylesheets) {\n      stylesheets.forEach((styleSrc) => {\n        ReactDOM.preinit(styleSrc, { as: 'style' })\n      })\n    }\n\n    // Before interactive scripts need to be loaded by Next.js' runtime instead\n    // of native <script> tags, because they no longer have `defer`.\n    if (strategy === 'beforeInteractive') {\n      if (!src) {\n        // For inlined scripts, we put the content in `children`.\n        if (restProps.dangerouslySetInnerHTML) {\n          // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n          restProps.children = restProps.dangerouslySetInnerHTML\n            .__html as string\n          delete restProps.dangerouslySetInnerHTML\n        }\n\n        return (\n          <script\n            nonce={nonce}\n            dangerouslySetInnerHTML={{\n              __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([\n                0,\n                { ...restProps, id },\n              ])})`,\n            }}\n          />\n        )\n      } else {\n        // @ts-ignore\n        ReactDOM.preload(\n          src,\n          restProps.integrity\n            ? {\n                as: 'script',\n                integrity: restProps.integrity,\n                nonce,\n                crossOrigin: restProps.crossOrigin,\n              }\n            : { as: 'script', nonce, crossOrigin: restProps.crossOrigin }\n        )\n        return (\n          <script\n            nonce={nonce}\n            dangerouslySetInnerHTML={{\n              __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([\n                src,\n                { ...restProps, id },\n              ])})`,\n            }}\n          />\n        )\n      }\n    } else if (strategy === 'afterInteractive') {\n      if (src) {\n        // @ts-ignore\n        ReactDOM.preload(\n          src,\n          restProps.integrity\n            ? {\n                as: 'script',\n                integrity: restProps.integrity,\n                nonce,\n                crossOrigin: restProps.crossOrigin,\n              }\n            : { as: 'script', nonce, crossOrigin: restProps.crossOrigin }\n        )\n      }\n    }\n  }\n\n  return null\n}\n\nObject.defineProperty(Script, '__nextScript', { value: true })\n\nexport default Script\n"],"names":["handleClientScriptLoad","initScriptLoader","ScriptCache","Map","LoadCache","Set","insertStylesheets","stylesheets","ReactDOM","preinit","forEach","stylesheet","as","window","head","document","link","createElement","type","rel","href","appendChild","loadScript","props","src","id","onLoad","onReady","dangerouslySetInnerHTML","children","strategy","onError","cacheKey","has","add","get","then","afterLoad","el","loadPromise","Promise","resolve","reject","addEventListener","e","call","catch","innerHTML","__html","textContent","Array","isArray","join","set","setAttributesFromProps","setAttribute","body","requestIdleCallback","loadLazyScript","readyState","addBeforeInteractiveToCache","scripts","querySelectorAll","script","getAttribute","scriptLoaderItems","Script","restProps","updateScripts","getIsSsr","appDir","nonce","useContext","HeadManagerContext","hasOnReadyEffectCalled","useRef","useEffect","current","hasLoadScriptEffectCalled","concat","styleSrc","JSON","stringify","preload","integrity","crossOrigin","Object","defineProperty","value"],"mappings":"","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/next/script.js"],"sourcesContent":["module.exports = require('./dist/client/script')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"file":"PrismicError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/PrismicError.ts"],"sourcesContent":["export class PrismicError<Response> extends Error {\n\turl?: string\n\tresponse: Response\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message)\n\n\t\tthis.url = url\n\t\tthis.response = response\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAM,MAAO,qBAA+B,MAAK;IAIhD,YACC,UAAU,sCAAA,EACV,GAAA,EACA,QAAA,CAAkB;QAElB,KAAA,CAAM,OAAO;QARd,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QASC,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,QAAA,GAAW;IACjB;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"file":"isRepositoryName.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/isRepositoryName.ts"],"sourcesContent":["/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false`\n *   otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input)\n}\n"],"names":[],"mappings":";;;AAQa,MAAA,mBAAmB,CAAC,UAA0B;IACnD,OAAA,2CAA2C,IAAA,CAAK,KAAK;AAC7D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"file":"getToolbarSrc.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/getToolbarSrc.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Returns the URL for a Prismic repository's Prismic Toolbar script. Use the\n * URL to inject the script into your app.\n *\n * @example\n *\n * ```typescriptreact\n * // In Next.js apps, use `next/script` in your `app/layout.tsx` file.\n *\n * import Script from \"next/script\";\n * import * as prismic from \"@prismicio/client\";\n *\n * export default function RootLayout({\n * \tchildren,\n * }: {\n * \tchildren: React.ReactNode,\n * }) {\n * \tconst toolbarSrc = prismic.getToolbarSrc(\"my-repo\");\n *\n * \treturn (\n * \t\t<html lang=\"en\">\n * \t\t\t<body>{children}</body>\n * \t\t\t<Script src={toolbarSrc} />\n * \t\t</html>\n * \t);\n * }\n * ```\n *\n * @param repositoryName - The name of the Prismic repository. For example,\n *   `\"my-repo\"` if the repository URL is `my-repo.prismic.io`.\n *\n * @returns The URL for the given Prismic repository's Prismic Toolbar script.\n */\nexport const getToolbarSrc = <TRepositoryName extends string>(\n\trepositoryName: TRepositoryName,\n): `https://static.cdn.prismic.io/prismic.js?new=true&repo=${TRepositoryName}` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://static.cdn.prismic.io/prismic.js?new=true&repo=${repositoryName}` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAqCa,MAAA,gBAAgB,CAC5B,mBACgF;IAC5E,0KAAA,mBAAA,EAAiB,cAAc,GAAG;QACrC,OAAO,CAAA,uDAAA,EAA0D,cAAc,EAAA;IAAA,OACzE;QACN,MAAM,4KAAI,eAAA,CACT,CAAA,8CAAA,EAAiD,cAAc,EAAA,EAC/D,KAAA,GACA,KAAA,CAAS;IAEX;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/next/dist/PrismicPreviewClient.js/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const PrismicPreviewClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call PrismicPreviewClient() from the server but PrismicPreviewClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/@prismicio/next/dist/PrismicPreviewClient.js <module evaluation>\",\n    \"PrismicPreviewClient\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,uBAAuB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtD;IAAa,MAAM,IAAI,MAAM;AAAwP,GACrR,2FACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/next/dist/PrismicPreviewClient.js/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const PrismicPreviewClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call PrismicPreviewClient() from the server but PrismicPreviewClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/@prismicio/next/dist/PrismicPreviewClient.js\",\n    \"PrismicPreviewClient\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,uBAAuB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtD;IAAa,MAAM,IAAI,MAAM;AAAwP,GACrR,uEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"file":"PrismicPreviewClient.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/next/src/PrismicPreviewClient.tsx"],"sourcesContent":["\"use client\";\n\nimport { FC, useEffect } from \"react\";\nimport { cookie as prismicCookie } from \"@prismicio/client\";\nimport { useRouter } from \"next/navigation\";\n\ntype PrismicPreviewClientProps = {\n\trepositoryName: string;\n\tisDraftMode: boolean;\n\tupdatePreviewURL?: string;\n\texitPreviewURL?: string;\n};\n\nexport const PrismicPreviewClient: FC<PrismicPreviewClientProps> = (props) => {\n\tconst {\n\t\trepositoryName,\n\t\tisDraftMode,\n\t\tupdatePreviewURL = \"/api/preview\",\n\t\texitPreviewURL = \"/api/exit-preview\",\n\t} = props;\n\n\tconst { refresh } = useRouter();\n\n\tuseEffect(() => {\n\t\tconst controller = new AbortController();\n\n\t\twindow.addEventListener(\"prismicPreviewUpdate\", onUpdate, {\n\t\t\tsignal: controller.signal,\n\t\t});\n\t\twindow.addEventListener(\"prismicPreviewEnd\", onEnd, {\n\t\t\tsignal: controller.signal,\n\t\t});\n\n\t\tconst cookie = getPrismicPreviewCookie(window.document.cookie);\n\t\tconst cookieRepositoryName = cookie\n\t\t\t? (decodeURIComponent(cookie).match(/\"([^\"]+)\\.prismic\\.io\"/) || [])[1]\n\t\t\t: undefined;\n\t\tconst hasCookieForRepository = cookieRepositoryName === repositoryName;\n\n\t\t// Start the preview for preview share links. Previews from\n\t\t// share links do not go to the `updatePreviewURL` like a normal\n\t\t// preview.\n\t\tif (hasCookieForRepository && !isDraftMode) {\n\t\t\tconsole.log(\"starting preview link\");\n\n\t\t\t// We check `opaqueredirect` because we don't care if\n\t\t\t// the redirect was successful or not. As long as it\n\t\t\t// redirects, we know the endpoint exists and draft mode\n\t\t\t// is active.\n\t\t\tglobalThis\n\t\t\t\t.fetch(updatePreviewURL, {\n\t\t\t\t\tredirect: \"manual\",\n\t\t\t\t\tsignal: controller.signal,\n\t\t\t\t})\n\t\t\t\t.then((res) => {\n\t\t\t\t\tif (res.type !== \"opaqueredirect\") {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t`[<PrismicPreview>] Failed to start the preview using \"${updatePreviewURL}\". Does it exist?`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\trefresh();\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// noop\n\t\t\t\t});\n\t\t}\n\n\t\tfunction onUpdate(event: Event) {\n\t\t\tevent.preventDefault();\n\t\t\trefresh();\n\t\t}\n\n\t\tfunction onEnd(event: Event) {\n\t\t\tevent.preventDefault();\n\t\t\tglobalThis\n\t\t\t\t.fetch(exitPreviewURL, { signal: controller.signal })\n\t\t\t\t.then((res) => {\n\t\t\t\t\tif (!res.ok) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t`[<PrismicPreview>] Failed to exit Preview Mode using the \"${exitPreviewURL}\" API endpoint. Does it exist?`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\trefresh();\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// noop\n\t\t\t\t});\n\t\t}\n\n\t\treturn () => controller.abort();\n\t}, [repositoryName, isDraftMode, updatePreviewURL, exitPreviewURL, refresh]);\n\n\treturn null;\n};\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the\n *   cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nfunction getPrismicPreviewCookie(cookieJar: string): string | undefined {\n\tfunction readValue(value: string): string {\n\t\treturn value.replace(/%3B/g, \";\");\n\t}\n\n\tconst cookies = cookieJar.split(\"; \");\n\n\tlet value: string | undefined;\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\");\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\");\n\n\t\tif (name === prismicCookie.preview) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn value;\n}\n"],"names":["cookie","value","prismicCookie"],"mappings":"","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"file":"PrismicPreview.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/next/src/PrismicPreview.tsx"],"sourcesContent":["import type { FC, ReactNode } from \"react\";\nimport Script from \"next/script\";\nimport { getToolbarSrc } from \"@prismicio/client\";\n\nimport { PrismicPreviewClient } from \"./PrismicPreviewClient.js\";\n\n/** Props for `<PrismicPreview>`. */\nexport type PrismicPreviewProps = {\n\t/**\n\t * The name of your Prismic repository. A Prismic Toolbar will be registered\n\t * using this repository.\n\t */\n\trepositoryName: string;\n\n\t/**\n\t * The URL of your app's Prismic preview endpoint (default: `/api/preview`).\n\t * This URL will be fetched on preview update events.\n\t */\n\tupdatePreviewURL?: string;\n\n\t/**\n\t * The URL of your app's exit preview endpoint (default: `/api/exit-preview`).\n\t * This URL will be fetched on preview exit events.\n\t */\n\texitPreviewURL?: string;\n\n\t/** Children to render adjacent to the Prismic Toolbar. */\n\tchildren?: ReactNode;\n};\n\n/**\n * React component that sets up Prismic Previews using the Prismic Toolbar. When\n * the Prismic Toolbar send events to the browser, such as on preview updates\n * and exiting, this component will automatically refresh the page with the\n * changes.\n *\n * This component can be wrapped around your app or added anywhere in your app's\n * tree. It must be rendered on every page.\n */\nexport const PrismicPreview: FC<PrismicPreviewProps> = async (props) => {\n\tconst { repositoryName, children, ...otherProps } = props;\n\n\t// Need this to avoid the following Next.js build-time error:\n\t// You're importing a component that needs next/headers. That only works\n\t// in a Server Component which is not supported in the pages/ directory.\n\tconst { draftMode } = await import(\"next/headers\");\n\n\tconst toolbarSrc = getToolbarSrc(repositoryName);\n\tconst isDraftMode = (await draftMode()).isEnabled;\n\n\treturn (\n\t\t<>\n\t\t\t{children}\n\t\t\t<PrismicPreviewClient\n\t\t\t\trepositoryName={repositoryName}\n\t\t\t\tisDraftMode={isDraftMode}\n\t\t\t\t{...otherProps}\n\t\t\t/>\n\t\t\t<Script src={toolbarSrc} strategy=\"lazyOnload\" />\n\t\t</>\n\t);\n};\n"],"names":["_jsxs","_Fragment","_jsx"],"mappings":";;;;;;;;;;;AAuCa,MAAA,iBAA0C,OAAO,UAAS;IACtE,MAAM,EAAE,cAAA,EAAgB,QAAA,EAAU,GAAG,WAAe,CAAA,GAAA;IAKpD,MAAM,EAAE,SAAA,CAAA,CAAA,GAAc,MAAM,OAAO,cAAc;IAE3C,MAAA,aAAa,mLAAA,EAAc,cAAc;IACzC,MAAA,cAAA,CAAe,MAAM,UAAA,CAAA,EAAa,SAAA;IAGvC,mOAAAA,OAAAA,yNAAAC,YAAAA,EAAA;QAAA,UAAA;YACE;wOACDC,MAAAA,sKAAC,uBAAA,EACA;gBAAA;gBACA;gBAAwB,GACpB,UAAA;YAAA,CAAU;wOAEfA,MAAAA,iIAAC,UAAA,EAAM;gBAAC,KAAK;gBAAY,UAAS;YAAA,CAAe,CAAA;SAAA;IAAA,CAAA;AAGpD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"file":"castArray.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/castArray.ts"],"sourcesContent":["/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n *\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => {\n\treturn Array.isArray(a) ? a : [a]\n}\n"],"names":[],"mappings":";;;AAWa,MAAA,YAAY,CAAI,MAAmB;IAC/C,OAAO,MAAM,OAAA,CAAQ,CAAC,IAAI,IAAI;QAAC,CAAC;KAAA;AACjC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"file":"appendFilters.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/appendFilters.ts"],"sourcesContent":["import { castArray } from \"./castArray\"\n\ninterface WithFilters {\n\tfilters?: string | string[]\n}\n\n/**\n * Adds one or more filters to an object with a `filters` property. Appended\n * filters are added to the end of the existing list.\n *\n * @typeParam T - Object to which filters will be append.\n *\n * @param objWithFilters - Object to append filters on the `filters` property.\n * @param filters - One or more filters to append.\n *\n * @returns The object with the appended filters.\n */\nexport const appendFilters = <T extends WithFilters>(\n\tobjWithFilters: T = {} as T,\n\tfilters: string | string[],\n): T & { filters: string[] } => {\n\treturn {\n\t\t...objWithFilters,\n\t\tfilters: [...(objWithFilters.filters || []), ...castArray(filters)],\n\t}\n}\n"],"names":[],"mappings":";;;;;AAiBO,MAAM,gBAAgB,CAC5B,iBAAoB,CAAA,CAAA,EACpB,YAC8B;IACvB,OAAA;QACN,GAAG,cAAA;QACH,SAAS,CAAC;eAAI,eAAe,OAAA,IAAW,CAAA,CAAA,EAAK;qLAAG,YAAA,EAAU,OAAO,CAAC;SAAA;IAAA;AAEpE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"file":"castThunk.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/castThunk.ts"],"sourcesContent":["/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n *\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) => {\n\treturn typeof a === \"function\" ? (a as () => A) : () => a\n}\n"],"names":[],"mappings":";;;AAUa,MAAA,YAAY,CAAI,MAA+B;IAC3D,OAAO,OAAO,MAAM,aAAc,IAAgB,IAAM;AACzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"file":"package.json.js","sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"file":"devMsg.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/devMsg.ts"],"sourcesContent":["import { version } from \"../../package.json\"\n\n/**\n * Returns a `prismic.dev/msg` URL for a given message slug.\n *\n * @example\n *\n * ```ts\n * devMsg(\"missing-param\")\n * // => \"https://prismic.dev/msg/client/v1.2.3/missing-param.md\"\n * ```\n *\n * @param slug - Slug for the message. This corresponds to a Markdown file in\n *   the Git repository's `/messages` directory.\n *\n * @returns The `prismic.dev/msg` URL for the given slug.\n */\nexport const devMsg = (slug: string): string => {\n\treturn `https://prismic.dev/msg/client/v${version}/${slug}`\n}\n"],"names":[],"mappings":";;;;;AAiBa,MAAA,SAAS,CAAC,SAAwB;IACvC,OAAA,CAAA,gCAAA,mKAAmC,UAAO,CAAA,CAAA,EAAI,IAAI,EAAA;AAC1D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"file":"filter.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/filter.ts"],"sourcesContent":["/**\n * Formats the value of a filter element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`\n\t}\n\n\treturn `${value}`\n}\n\n/**\n * Creates a filter builder function for filters with a path and arguments.\n *\n * @typeParam Args - Arguments for the filter.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathWithArgsFilter = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \")\n\t\tconst joiner = path && args.length ? \", \" : \"\"\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only a path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathFilter = (name: string) => {\n\tconst filterFn = pathWithArgsFilter(name)\n\n\t/**\n\t * @param path - Path for the filter.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn filterFn(path)\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only arguments and no\n * path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst argsFilter = <Args extends unknown[]>(name: string) => {\n\tconst filterFn = pathWithArgsFilter<Args>(name)\n\n\t/**\n\t * @param args - Arguments for the filter.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn filterFn(\"\", ...args)\n\t}\n\n\treturn fn\n}\n\nexport const filter = {\n\t/**\n\t * The `at` filter checks that the path matches the described value exactly.\n\t * It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#at}\n\t */\n\tat: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"at\",\n\t),\n\n\t/**\n\t * The `not` filter checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#not}\n\t */\n\tnot: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"not\",\n\t),\n\n\t/**\n\t * The `any` filter takes an array of values. It works exactly the same way as\n\t * the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#any}\n\t */\n\tany: pathWithArgsFilter<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` filter is used specifically to retrieve an array of documents by\n\t * their IDs or UIDs. This filter is much more efficient at this than the any\n\t * filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#in}\n\t */\n\tin: pathWithArgsFilter<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` filter provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom type’s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}\n\t */\n\tfulltext: pathWithArgsFilter<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` filter checks whether a fragment has a value. It will return all\n\t * the documents of the specified type that contain a value for the specified\n\t * field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#has}\n\t */\n\thas: pathFilter(\"has\"),\n\n\t/**\n\t * The `missing` filter checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#missing}\n\t */\n\tmissing: pathFilter(\"missing\"),\n\n\t/**\n\t * The `similar` filter takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#similar}\n\t */\n\tsimilar: argsFilter<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` filter checks that the value in the path is within the\n\t * radius of the given coordinates.\n\t *\n\t * This filter will only work for a geopoint field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsFilter<[latitude: number, longitude: number, radius: number]>(\n\t\t\t\"geopoint.near\",\n\t\t),\n\n\t/**\n\t * The `number.lt` filter checks that the value in the number field is less\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}\n\t */\n\tnumberLessThan: pathWithArgsFilter<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` filter checks that the value in the number field is greater\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}\n\t */\n\tnumberGreaterThan: pathWithArgsFilter<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` filter checks that the value in the path is within the\n\t * two values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsFilter<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` filter checks that the value in the path is after the date\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateAfter: pathWithArgsFilter<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` filter checks that the value in the path is before the\n\t * date value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBefore: pathWithArgsFilter<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` filter checks that the value in the path is within the\n\t * date values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBetween:\n\t\tpathWithArgsFilter<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` filter checks that the value in the path is equal\n\t * to the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonth: pathWithArgsFilter<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` filter checks that the value in the path is\n\t * after the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` filter checks that the value in the path is\n\t * before the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` filter checks that the value in the path is equal to\n\t * the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeek: pathWithArgsFilter<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` filter checks that the value in the path is\n\t * after the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before filter checks that the value in the path is\n\t * before the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` filter checks that the value in the path occurs in the\n\t * month value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonth: pathWithArgsFilter<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` filter checks that the value in the path occurs in\n\t * any month after the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` filter checks that the value in the path occurs in\n\t * any month before the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` filter checks that the value in the path occurs in the year\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateYear: pathWithArgsFilter<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` filter checks that the value in the path occurs within the\n\t * hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHour: pathWithArgsFilter<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` filter checks that the value in the path occurs after\n\t * the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourAfter: pathWithArgsFilter<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` filter checks that the value in the path occurs\n\t * before the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourBefore: pathWithArgsFilter<[hour: number]>(\"date.hour-before\"),\n}\n"],"names":[],"mappings":";;;AAQA,MAAM,cAAc,CACnB,UAMW;IACP,IAAA,MAAM,OAAA,CAAQ,KAAK,GAAG;QACzB,OAAO,CAAA,CAAA,EAAI,MAAM,GAAA,CAAI,WAAW,EAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAA;IAC7C;IAEI,IAAA,OAAO,UAAU,UAAU;QAC9B,OAAO,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAA;IACjB;IAEA,IAAI,iBAAiB,MAAM;QACnB,OAAA,GAAG,MAAM,OAAA,CAAA,CAAS,EAAA;IAC1B;IAEA,OAAO,GAAG,KAAK,EAAA;AAChB;AAWA,MAAM,qBAAqB,CAAyB,SAAgB;IAI7D,MAAA,KAAK,CAAC,MAAA,GAAiB,SAAsB;QAClD,MAAM,gBAAgB,KAAK,GAAA,CAAI,WAAW,EAAE,IAAA,CAAK,IAAI;QACrD,MAAM,SAAS,QAAQ,KAAK,MAAA,GAAS,OAAO;QAE5C,OAAO,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA,EAAI,IAAI,GAAG,MAAM,GAAG,aAAa,CAAA,EAAA,CAAA;IAAA;IAG1C,OAAA;AACR;AASA,MAAM,aAAa,CAAC,SAAgB;IAC7B,MAAA,WAAW,mBAAmB,IAAI;IAKlC,MAAA,KAAK,CAAC,SAAwB;QACnC,OAAO,SAAS,IAAI;IAAA;IAGd,OAAA;AACR;AAUA,MAAM,aAAa,CAAyB,SAAgB;IACrD,MAAA,WAAW,mBAAyB,IAAI;IAKxC,MAAA,KAAK,CAAA,GAAI,SAAsB;QAC7B,OAAA,SAAS,IAAI,GAAG,IAAI;IAAA;IAGrB,OAAA;AACR;AAEO,MAAM,SAAS;IAAA;;;;;GAAA,GAOrB,IAAI,mBACH,IAAI;IAAA;;;;;GAAA,GASL,KAAK,mBACJ,KAAK;IAAA;;;;;;GAAA,GAUN,KAAK,mBACJ,KAAK;IAAA;;;;;;GAAA,GAUN,IAAI,mBAAuC,IAAI;IAAA;;;;;;;;;GAAA,GAY/C,UAAU,mBAA0C,UAAU;IAAA;;;;;;GAAA,GAS9D,KAAK,WAAW,KAAK;IAAA;;;;;;GAAA,GASrB,SAAS,WAAW,SAAS;IAAA;;;;;;GAAA,GAS7B,SAAS,WAAwC,SAAS;IAAA;;;;;;;GAAA,GAU1D,cACC,mBACC,eAAe;IAAA;;;;;GAAA,GASjB,gBAAgB,mBAAoC,WAAW;IAAA;;;;;GAAA,GAQ/D,mBAAmB,mBAAoC,WAAW;IAAA;;;;;GAAA,GAQlE,eACC,mBACC,gBAAgB;IAAA;;;;;GAAA,GASlB,WAAW,mBAAmD,YAAY;IAAA;;;;;GAAA,GAQ1E,YAAY,mBAAmD,aAAa;IAAA;;;;;GAAA,GAQ5E,aACC,mBAEE,cAAc;IAAA;;;;;GAAA,GAQjB,gBAAgB,mBAAkC,mBAAmB;IAAA;;;;;GAAA,GAQrE,qBAAqB,mBACpB,yBAAyB;IAAA;;;;;GAAA,GAS1B,sBAAsB,mBACrB,0BAA0B;IAAA;;;;;GAAA,GAS3B,eAAe,mBAA2C,kBAAkB;IAAA;;;;;GAAA,GAQ5E,oBAAoB,mBACnB,wBAAwB;IAAA;;;;;GAAA,GASzB,qBAAqB,mBACpB,yBAAyB;IAAA;;;;;GAAA,GAS1B,WAAW,mBAA6C,YAAY;IAAA;;;;;GAAA,GAQpE,gBACC,mBAA6C,kBAAkB;IAAA;;;;;GAAA,GAQhE,iBACC,mBAA6C,mBAAmB;IAAA;;;;;GAAA,GAQjE,UAAU,mBAAmC,WAAW;IAAA;;;;;GAAA,GAQxD,UAAU,mBAAmC,WAAW;IAAA;;;;;GAAA,GAQxD,eAAe,mBAAmC,iBAAiB;IAAA;;;;;GAAA,GAQnE,gBAAgB,mBAAmC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 485, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"file":"everyTagFilter.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/everyTagFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\nimport { castArray } from \"./castArray\"\n\n/**\n * Creates a filter to filter content by document tags. All tags are required on\n * the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const everyTagFilter = (tags: string | string[]): string => {\n\treturn filter.at(\"document.tags\", castArray(tags))\n}\n"],"names":[],"mappings":";;;;;;;AAYa,MAAA,iBAAiB,CAAC,SAAmC;IACjE,+JAAO,SAAA,CAAO,EAAA,CAAG,uLAAiB,YAAA,EAAU,IAAI,CAAC;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"file":"findRef.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/findRef.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { PrismicError } from \"../errors/PrismicError\"\n\n/**\n * Returns the first ref from a list that passes a filter (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param filter - A function that determines if a ref from the list matches the\n *   criteria.\n *\n * @returns The first matching ref.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (refs: Ref[], filter: (ref: Ref) => boolean): Ref => {\n\tconst ref = refs.find((ref) => filter(ref))\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined)\n\t}\n\n\treturn ref\n}\n"],"names":["ref"],"mappings":";;;;;AAgBa,MAAA,UAAU,CAAC,MAAa,WAAsC;IAC1E,MAAM,MAAM,KAAK,IAAA,CAAK,CAACA,OAAQ,OAAOA,IAAG,CAAC;IAE1C,IAAI,CAAC,KAAK;QACT,MAAM,4KAAI,eAAA,CAAa,2BAA2B,KAAA,GAAW,KAAA,CAAS;IACvE;IAEO,OAAA;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 523, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"file":"findMasterRef.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/findMasterRef.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: Ref[]): Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef)\n}\n"],"names":[],"mappings":";;;;;AAaa,MAAA,gBAAgB,CAAC,SAAoB;IACjD,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,WAAW;AAC9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 539, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"file":"findRefByID.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/findRefByID.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: Ref[], id: string): Ref => {\n\treturn findRef(refs, (ref) => ref.id === id)\n}\n"],"names":[],"mappings":";;;;;AAca,MAAA,cAAc,CAAC,MAAa,OAAmB;IAC3D,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,EAAA,KAAO,EAAE;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 555, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"file":"findRefByLabel.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/findRefByLabel.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (refs: Ref[], label: string): Ref => {\n\treturn findRef(refs, (ref) => ref.label === label)\n}\n"],"names":[],"mappings":";;;;;AAca,MAAA,iBAAiB,CAAC,MAAa,UAAsB;IACjE,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,KAAA,KAAU,KAAK;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"file":"cookie.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/cookie.ts"],"sourcesContent":["/**\n * The well-known name of the cookie used to store a Prismic preview session's\n * ref.\n */\nexport const preview = \"io.prismic.preview\"\n"],"names":[],"mappings":";;;AAIO,MAAM,UAAU","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"file":"getPreviewCookie.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/getPreviewCookie.ts"],"sourcesContent":["import { preview as previewCookieName } from \"../cookie\"\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\")\n}\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the\n *   cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getPreviewCookie = (cookieJar: string): string | undefined => {\n\tconst cookies = cookieJar.split(\"; \")\n\n\tlet value: string | undefined\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\")\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\")\n\n\t\tif (name === previewCookieName) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"))\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn value\n}\n"],"names":["previewCookieName"],"mappings":";;;;;AAEA,MAAM,YAAY,CAAC,UAAyB;IACpC,OAAA,MAAM,OAAA,CAAQ,QAAQ,GAAG;AACjC;AAUa,MAAA,mBAAmB,CAAC,cAAyC;IACnE,MAAA,UAAU,UAAU,KAAA,CAAM,IAAI;IAEhC,IAAA;IAEJ,KAAA,MAAW,UAAU,QAAS;QACvB,MAAA,QAAQ,OAAO,KAAA,CAAM,GAAG;QACxB,MAAA,OAAO,UAAU,KAAA,CAAM,CAAC,CAAC,EAAE,OAAA,CAAQ,QAAQ,GAAG;QAEpD,IAAI,iKAASA,UAAAA,EAAmB;YAC/B,QAAQ,UAAU,MAAM,KAAA,CAAM,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC;YAC1C;QACD;IACD;IAEO,OAAA;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 612, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"file":"minifyGraphQLQuery.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/minifyGraphQLQuery.ts"],"sourcesContent":["/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t)\n}\n"],"names":[],"mappings":";;;AAOa,MAAA,qBAAqB,CAAC,UAAyB;IAC3D,OAAO,MAAM,OAAA,CACZ,2BACA,CAAC,QAAQ,SAAS,WAAa,QAAQ;AAEzC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 632, "column": 0}, "map": {"version":3,"file":"someTagsFilter.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/someTagsFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\nimport { castArray } from \"./castArray\"\n\n/**\n * Creates a filter to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const someTagsFilter = (tags: string | string[]): string => {\n\treturn filter.any(\"document.tags\", castArray(tags))\n}\n"],"names":[],"mappings":";;;;;;;AAYa,MAAA,iBAAiB,CAAC,SAAmC;IACjE,+JAAO,SAAA,CAAO,GAAA,CAAI,uLAAiB,YAAA,EAAU,IAAI,CAAC;AACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 650, "column": 0}, "map": {"version":3,"file":"typeFilter.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/typeFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\n/**\n * Creates a filter to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const typeFilter = (documentType: string): string => {\n\treturn filter.at(\"document.type\", documentType)\n}\n"],"names":[],"mappings":";;;;;AASa,MAAA,aAAa,CAAC,iBAAgC;IACnD,+JAAA,SAAA,CAAO,EAAA,CAAG,iBAAiB,YAAY;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 660, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"file":"ForbiddenError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/ForbiddenError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string\n\tmessage: string\n}\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string\n}\n\nexport class ForbiddenError<\n\tTResponse =\n\t\t| ForbiddenErrorRepositoryAPIResponse\n\t\t| ForbiddenErrorQueryAPIResponse,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,+LAIH,eAAA,CAAuB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"file":"NotFoundError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/NotFoundError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\nexport class NotFoundError<\n\tTResponse = undefined,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAEM,MAAO,8LAEH,eAAA,CAAuB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 690, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 696, "column": 0}, "map": {"version":3,"file":"ParsingError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/ParsingError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\"\n\tmessage: string\n\tline: number\n\tcolumn: number\n\tid: number\n\tlocation: string\n}\n\nexport class ParsingError<\n\tTResponse = ParsingErrorAPIResponse,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,6LAEH,eAAA,CAAuB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 711, "column": 0}, "map": {"version":3,"file":"PreviewTokenExpired.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/PreviewTokenExpired.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype PreviewTokenExpiredErrorAPIResponse = {\n\ttype: \"api_security_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class PreviewTokenExpiredError<\n\tTResponse = PreviewTokenExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AASM,MAAO,2MAEH,iBAAA,CAAyB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 720, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"file":"RefExpiredError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/RefExpiredError.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype RefExpiredErrorAPIResponse = {\n\ttype: \"api_validation_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 410 for expired refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefExpiredError<\n\tTResponse = RefExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,kMAEH,iBAAA,CAAyB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"file":"RefNotFoundError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/RefNotFoundError.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype RefNotFoundErrorAPIResponse = {\n\ttype: \"api_notfound_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 404 for not found refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefNotFoundError<\n\tTResponse = RefNotFoundErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,mMAEH,iBAAA,CAAyB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 750, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 756, "column": 0}, "map": {"version":3,"file":"RepositoryNotFoundError.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/errors/RepositoryNotFoundError.ts"],"sourcesContent":["import { NotFoundError } from \"./NotFoundError\"\n\nexport class RepositoryNotFoundError<\n\tTResponse = undefined,\n> extends NotFoundError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAEM,MAAO,yMAEH,gBAAA,CAAwB;AAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"file":"link.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/types/value/link.ts"],"sourcesContent":["import type { AnyRegularField, FieldState } from \"./types\"\n\nimport type { FilledContentRelationshipField } from \"./contentRelationship\"\nimport type { GroupField } from \"./group\"\nimport type { FilledLinkToMediaField } from \"./linkToMedia\"\nimport type { SliceZone } from \"./sliceZone\"\n\n/**\n * Link types\n */\nexport const LinkType = {\n\tAny: \"Any\",\n\tDocument: \"Document\",\n\tMedia: \"Media\",\n\tWeb: \"Web\",\n} as const\n\n/**\n * A link field.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled via the\n *   `fetchLinks` or `graphQuery` query parameter).\n * @typeParam State - State of the field which determines its shape.\n * @typeParam Variant - Variants of the link.\n */\nexport type LinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tState extends FieldState = FieldState,\n\tVariant = string,\n> = State extends \"empty\"\n\t? EmptyLinkField<typeof LinkType.Any, Variant>\n\t: FilledLinkField<TypeEnum, LangEnum, DataInterface, Variant>\n\n/**\n * A link field that is filled.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled via the\n *   `fetchLinks` or `graphQuery` query parameter).\n * @typeParam Variant - Variants of the link.\n */\nexport type FilledLinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tVariant = string,\n> =\n\t| (FilledContentRelationshipField<TypeEnum, LangEnum, DataInterface> &\n\t\t\tOptionalLinkProperties<Variant>)\n\t| FilledLinkToMediaField<Variant>\n\t| FilledLinkToWebField<Variant>\n\n/**\n * A link field that is not filled.\n *\n * @typeParam _Unused - THIS PARAMETER IS NOT USED. If you are passing a type,\n *   **please remove it**.\n * @typeParam Variant - Variants of the link.\n */\nexport type EmptyLinkField<\n\t_Unused extends\n\t\t(typeof LinkType)[keyof typeof LinkType] = typeof LinkType.Any,\n\tVariant = string,\n> = {\n\tlink_type: \"Any\"\n} & OptionalLinkProperties<Variant>\n\n/**\n * A link field pointing to a relative or absolute URL.\n *\n * @typeParam Variant - Variants of the link.\n */\nexport type FilledLinkToWebField<Variant = string> = {\n\tlink_type: \"Web\"\n\turl: string\n\ttarget?: string\n} & OptionalLinkProperties<Variant>\n\n/**\n * Optional properties available to link fields. It is used to augment existing\n * link-like fields (like content relationship fields) with field-specific\n * properties.\n *\n * @typeParam Variant - Variants of the link.\n *\n * @internal\n */\n// Remember to update the `getOptionalLinkProperties()` function when updating\n// this type. The function should check for every property.\nexport type OptionalLinkProperties<Variant = string> = {\n\ttext?: string\n\tvariant?: Variant\n}\n"],"names":[],"mappings":";;;AAUO,MAAM,WAAW;IACvB,KAAK;IACL,UAAU;IACV,OAAO;IACP,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 782, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 788, "column": 0}, "map": {"version":3,"file":"documentToLinkField.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/helpers/documentToLinkField.ts"],"sourcesContent":["import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport { LinkType } from \"../types/value/link\"\n\ntype SetOptional<T, Keys extends keyof T> = Omit<T, Keys> &\n\tPartial<Pick<T, Keys>>\n\n/**\n * Converts a document into a link field, this is useful when crawling the API\n * for document links\n *\n * @typeParam TDocument - Specific interface of the provided document\n *\n * @param prismicDocument - A document coming from Prismic\n *\n * @returns The equivalent link field to use with `asLink()`\n *\n * @internal\n */\nexport const documentToLinkField = <\n\tTDocument extends SetOptional<PrismicDocument, \"slugs\">,\n>(\n\tprismicDocument: TDocument,\n): FilledContentRelationshipField<\n\tTDocument[\"type\"],\n\tTDocument[\"lang\"],\n\tTDocument[\"data\"]\n> => {\n\treturn {\n\t\tlink_type: LinkType.Document,\n\t\tid: prismicDocument.id,\n\t\tuid: prismicDocument.uid || undefined,\n\t\ttype: prismicDocument.type,\n\t\ttags: prismicDocument.tags,\n\t\tlang: prismicDocument.lang,\n\t\turl: prismicDocument.url == null ? undefined : prismicDocument.url,\n\t\tslug: prismicDocument.slugs?.[0], // Slug field is not available with GraphQL\n\t\t// The REST API does not include a `data` property if the data\n\t\t// object is empty.\n\t\t//\n\t\t// A presence check for `prismicDocument.data` is done to\n\t\t// support partial documents. While `documentToLinkField` is\n\t\t// not typed to accept partial documents, passing a partial\n\t\t// document can happen in untyped projects.\n\t\t...(prismicDocument.data && Object.keys(prismicDocument.data).length > 0\n\t\t\t? { data: prismicDocument.data }\n\t\t\t: {}),\n\t}\n}\n"],"names":[],"mappings":";;;;;AAmBa,MAAA,sBAAsB,CAGlC,oBAKG;;IACI,OAAA;QACN,mLAAW,WAAA,CAAS,QAAA;QACpB,IAAI,gBAAgB,EAAA;QACpB,KAAK,gBAAgB,GAAA,IAAO,KAAA;QAC5B,MAAM,gBAAgB,IAAA;QACtB,MAAM,gBAAgB,IAAA;QACtB,MAAM,gBAAgB,IAAA;QACtB,KAAK,gBAAgB,GAAA,IAAO,OAAO,KAAA,IAAY,gBAAgB,GAAA;QAC/D,MAAA,CAAM,KAAA,gBAAgB,KAAA,KAAhB,OAAA,KAAA,IAAA,EAAA,CAAwB,EAAA;QAAA,2CAAA;QAAA,8DAAA;QAAA,mBAAA;QAAA,EAAA;QAAA,yDAAA;QAAA,4DAAA;QAAA,2DAAA;QAAA,2CAAA;QAQ9B,GAAI,gBAAgB,IAAA,IAAQ,OAAO,IAAA,CAAK,gBAAgB,IAAI,EAAE,MAAA,GAAS,IACpE;YAAE,MAAM,gBAAgB,IAAA;QAAA,IACxB,CAAA,CAAA;;AAEL","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"file":"asLink.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/helpers/asLink.ts"],"sourcesContent":["import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { FilledLinkToWebField, LinkField } from \"../types/value/link\"\nimport { LinkType } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\n\nimport { documentToLinkField } from \"./documentToLinkField\"\n\n/**\n * Resolves a link to a Prismic document to a URL\n *\n * @typeParam ReturnType - Return type of your link resolver function, useful if\n *   you prefer to return a complex object\n *\n * @param linkToDocumentField - A document link field to resolve\n *\n * @returns Resolved URL\n *\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n */\nexport type LinkResolverFunction<ReturnType = string | null | undefined> = (\n\tlinkToDocumentField: FilledContentRelationshipField,\n) => ReturnType\n\n/**\n * Configuration that determines the output of `asLink()`.\n */\ntype AsLinkConfig<LinkResolverFunctionReturnType = string | null | undefined> =\n\t{\n\t\t/**\n\t\t * An optional link resolver function. Without it, you are expected to use\n\t\t * the `routes` options from the API.\n\t\t */\n\t\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null\n\t}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsLinkDeprecatedTupleConfig<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n> = [linkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null]\n\n/**\n * The return type of `asLink()`.\n */\nexport type AsLinkReturnType<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? LinkResolverFunctionReturnType | string | null\n\t: null\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asLink: {\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param config - Configuration that determines the output of `asLink()`\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\tconfig?: AsLinkConfig<LinkResolverFunctionReturnType>,\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param linkResolver - An optional link resolver function. Without it, you\n\t *   are expected to use the `routes` options from the API\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\t...config: AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n} = <\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple:\n\t\t| [config?: AsLinkConfig<LinkResolverFunctionReturnType>]\n\t\t| AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n): AsLinkReturnType<LinkResolverFunctionReturnType, Field> => {\n\tif (!linkFieldOrDocument) {\n\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n\n\t// Converts document to link field if needed\n\tconst linkField =\n\t\t// prettier-ignore\n\t\t(\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t// TODO: Remove the `prettier-ignore` comment when this bug is fixed.\n\t\t\t\"link_type\" in linkFieldOrDocument\n\t\t\t\t? linkFieldOrDocument\n\t\t\t\t: documentToLinkField(linkFieldOrDocument)\n\t\t) as LinkField\n\n\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\tconst [configObjectOrLinkResolver] = configObjectOrTuple\n\tlet config: AsLinkConfig<LinkResolverFunctionReturnType>\n\tif (\n\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\tconfigObjectOrLinkResolver == null\n\t) {\n\t\tconfig = {\n\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t}\n\t} else {\n\t\tconfig = { ...configObjectOrLinkResolver }\n\t}\n\n\tswitch (linkField.link_type) {\n\t\tcase LinkType.Media:\n\t\tcase LinkType.Web:\n\t\t\treturn (\"url\" in linkField ? linkField.url : null) as AsLinkReturnType<\n\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\tField\n\t\t\t>\n\n\t\tcase LinkType.Document: {\n\t\t\tif (\"id\" in linkField && config.linkResolver) {\n\t\t\t\t// When using link resolver...\n\t\t\t\tconst resolvedURL = config.linkResolver(linkField)\n\n\t\t\t\tif (resolvedURL != null) {\n\t\t\t\t\treturn resolvedURL as AsLinkReturnType<\n\t\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\t\tField\n\t\t\t\t\t>\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"url\" in linkField && linkField.url) {\n\t\t\t\t// When using route resolver...\n\t\t\t\treturn linkField.url as AsLinkReturnType<\n\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\tField\n\t\t\t\t>\n\t\t\t}\n\n\t\t\t// When empty or link resolver and route resolver are not used...\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t\t}\n\n\t\tcase LinkType.Any:\n\t\tdefault:\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AA+Da,MAAA,SA6DT,CAQH,qBAAA,GAEG,wBAGyD;IAC5D,IAAI,CAAC,qBAAqB;QAClB,OAAA;IACR;IAGM,MAAA,YAAA,kBAAA;IAAA,6DAAA;IAAA,2FAAA;IAAA,qEAAA;IAMJ,eAAe,sBACZ,0MACA,sBAAA,EAAoB,mBAAmB;IAItC,MAAA,CAAC,0BAA0B,CAAA,GAAI;IACjC,IAAA;IACJ,IACC,OAAO,+BAA+B,cACtC,8BAA8B,MAC7B;QACQ,SAAA;YACR,cAAc;QAAA;IAAA,OAET;QACG,SAAA;YAAE,GAAG,0BAAA;QAAA;IACf;IAEA,OAAQ,UAAU,SAAA,EAAW;QAC5B,6KAAK,WAAA,CAAS,KAAA;QACd,6KAAK,WAAA,CAAS,GAAA;YACL,OAAA,SAAS,YAAY,UAAU,GAAA,GAAM;QAK9C,6KAAK,WAAA,CAAS,QAAA;YAAU;gBACnB,IAAA,QAAQ,aAAa,OAAO,YAAA,EAAc;oBAEvC,MAAA,cAAc,OAAO,YAAA,CAAa,SAAS;oBAEjD,IAAI,eAAe,MAAM;wBACjB,OAAA;oBAIR;gBACD;gBAEI,IAAA,SAAS,aAAa,UAAU,GAAA,EAAK;oBAExC,OAAO,UAAU,GAAA;gBAIlB;gBAGO,OAAA;YACR;QAEA,6KAAK,WAAA,CAAS,GAAA;QACd;YACQ,OAAA;IACT;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 876, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 882, "column": 0}, "map": {"version":3,"file":"pLimit.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/lib/pLimit.ts"],"sourcesContent":["/*\n ** Core logic from https://github.com/sindresorhus/p-limit\n ** Many thanks to @sindresorhus\n */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...arguments_: readonly any[]) => unknown\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * @param fn - Promise-returning/async function.\n * @param arguments - Any arguments to pass through to `fn`. Support for passing\n *   arguments on to the `fn` is provided in order to be able to avoid creating\n *   unnecessary closures. You probably don't need this optimization unless\n *   you're pushing a lot of functions.\n *\n * @returns The promise returned by calling `fn(...arguments)`.\n */\nexport type LimitFunction = <TArguments extends unknown[], TReturnType>(\n\tfunction_: (\n\t\t...arguments_: TArguments\n\t) => PromiseLike<TReturnType> | TReturnType,\n\t...arguments_: TArguments\n) => Promise<TReturnType>\n\n/**\n * Creates a limiting function that will only execute one promise at a time and\n * respect a given interval between each call.\n *\n * @param args - Options for the function, `interval` is the minimum time to\n *   wait between each promise execution.\n *\n * @returns A limiting function as per configuration, see {@link LimitFunction}.\n */\nexport const pLimit = ({\n\tinterval,\n}: { interval?: number } = {}): LimitFunction => {\n\tconst queue: AnyFunction[] = []\n\tlet busy = false\n\tlet lastCompletion = 0\n\n\tconst resumeNext = () => {\n\t\tif (!busy && queue.length > 0) {\n\t\t\tqueue.shift()?.()\n\t\t\tbusy = true\n\t\t}\n\t}\n\n\tconst next = () => {\n\t\tbusy = false\n\n\t\tresumeNext()\n\t}\n\n\tconst run = async (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\tconst timeSinceLastCompletion = Date.now() - lastCompletion\n\n\t\tif (interval && timeSinceLastCompletion < interval) {\n\t\t\tawait sleep(interval - timeSinceLastCompletion)\n\t\t}\n\t\tconst result = (async () => function_(...arguments_))()\n\n\t\tresolve(result)\n\n\t\ttry {\n\t\t\tawait result\n\t\t} catch {}\n\n\t\tlastCompletion = Date.now()\n\n\t\tnext()\n\t}\n\n\tconst enqueue = (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise((internalResolve) => {\n\t\t\tqueue.push(internalResolve)\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_))\n\t\t;(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve()\n\n\t\t\tif (!busy) {\n\t\t\t\tresumeNext()\n\t\t\t}\n\t\t})()\n\t}\n\n\treturn ((function_: AnyFunction, ...arguments_: unknown[]) =>\n\t\tnew Promise<unknown>((resolve) => {\n\t\t\tenqueue(function_, resolve, arguments_)\n\t\t})) as LimitFunction\n}\n"],"names":[],"mappings":";;;AAQA,MAAM,QAAQ,CAAC,KAAe,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,EAAE,CAAC;AA2BvE,MAAM,SAAS,CAAC,EACtB,QAAA,CAAQ,CAAA,GACkB,CAAA,CAAA,KAAqB;IAC/C,MAAM,QAAuB,CAAA,CAAA;IAC7B,IAAI,OAAO;IACX,IAAI,iBAAiB;IAErB,MAAM,aAAa,MAAK;QAlCzB,IAAA;QAmCE,IAAI,CAAC,QAAQ,MAAM,MAAA,GAAS,GAAG;YAC9B,CAAA,KAAA,MAAM,KAAA,EAAA,KAAN,OAAA,KAAA,IAAA;YACO,OAAA;QACR;IAAA;IAGD,MAAM,OAAO,MAAK;QACV,OAAA;;;IAKR,MAAM,MAAM,OACX,WACA,SACA,eACG;QACG,MAAA,0BAA0B,KAAK,GAAA,CAAA,IAAQ;QAEzC,IAAA,YAAY,0BAA0B,UAAU;YAC7C,MAAA,MAAM,WAAW,uBAAuB;QAC/C;QACA,MAAM,SAAA,CAAU,UAAY,UAAU,GAAG,UAAU,CAAA;QAEnD,QAAQ,MAAM;QAEV,IAAA;YACG,MAAA;QAAA,EAAA,OACC,CAAC;QAET,iBAAiB,KAAK,GAAA;;;IAKvB,MAAM,UAAU,CACf,WACA,SACA,eACG;QAGC,IAAA,QAAQ,CAAC,oBAAmB;YAC/B,MAAM,IAAA,CAAK,eAAe;QAAA,CAC1B,EAAE,IAAA,CAAK,IAAI,IAAA,CAAK,KAAA,GAAW,WAAW,SAAS,UAAU,CAAC;QAC1D,CAAC,YAAW;YAKZ,MAAM,QAAQ,OAAA;YAEd,IAAI,CAAC,MAAM;;YAEX;QAAA,CAAA;;IAIF,OAAQ,CAAC,WAAA,GAA2B,aACnC,IAAI,QAAiB,CAAC,YAAW;YACxB,QAAA,WAAW,SAAS,UAAU;QAAA,CACtC;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 931, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 937, "column": 0}, "map": {"version":3,"file":"BaseClient.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/BaseClient.ts"],"sourcesContent":["import { type LimitFunction, pLimit } from \"./lib/pLimit\"\n\nimport { PrismicError } from \"./errors/PrismicError\"\n\n/**\n * The default delay used with APIs not providing rate limit headers.\n *\n * @internal\n */\nexport const UNKNOWN_RATE_LIMIT_DELAY = 1500\n\n/**\n * A universal API to make network requests. A subset of the `fetch()` API.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch}\n */\nexport type FetchLike = (\n\tinput: string,\n\tinit?: RequestInitLike,\n) => Promise<ResponseLike>\n\n/**\n * An object that allows you to abort a `fetch()` request if needed via an\n * `AbortController` object\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n */\n// `any` is used often here to ensure this type is universally valid among\n// different AbortSignal implementations. The types of each property are not\n// important to validate since it is blindly passed to a given `fetch()`\n// function.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbortSignalLike = any\n\n/**\n * A subset of RequestInit properties to configure a `fetch()` request.\n */\n// Only options relevant to the client are included. Extending from the full\n// RequestInit would cause issues, such as accepting Header objects.\n//\n// An interface is used to allow other libraries to augment the type with\n// environment-specific types.\nexport interface RequestInitLike extends Pick<RequestInit, \"cache\"> {\n\t/**\n\t * The HTTP method to use for the request.\n\t */\n\tmethod?: string\n\n\t/**\n\t * The request body to send with the request.\n\t */\n\t// We want to keep the body type as compatible as possible, so\n\t// we only declare the type we need and accept anything else.\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tbody?: any | FormData | string\n\n\t/**\n\t * An object literal to set the `fetch()` request's headers.\n\t */\n\theaders?: Record<string, string>\n\n\t/**\n\t * An AbortSignal to set the `fetch()` request's signal.\n\t *\n\t * See:\n\t * [https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n\t */\n\t// NOTE: `AbortSignalLike` is `any`! It is left as `AbortSignalLike`\n\t// for backwards compatibility (the type is exported) and to signal to\n\t// other readers that this should be an AbortSignal-like object.\n\tsignal?: AbortSignalLike\n}\n\n/**\n * The minimum required properties from Response.\n */\nexport interface ResponseLike {\n\tok: boolean\n\tstatus: number\n\theaders: HeadersLike\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tjson(): Promise<any>\n\ttext(): Promise<string>\n\tblob(): Promise<Blob>\n}\n\n/**\n * The minimum required properties from Headers.\n */\nexport interface HeadersLike {\n\tget(name: string): string | null\n}\n\n/**\n * The minimum required properties to treat as an HTTP Request for automatic\n * Prismic preview support.\n */\nexport type HttpRequestLike =\n\t| /**\n\t * Web API Request\n\t *\n\t * @see http://developer.mozilla.org/en-US/docs/Web/API/Request\n\t */\n\t{\n\t\t\theaders?: {\n\t\t\t\tget(name: string): string | null\n\t\t\t}\n\t\t\turl?: string\n\t  }\n\n\t/**\n\t * Express-style Request\n\t */\n\t| {\n\t\t\theaders?: {\n\t\t\t\tcookie?: string\n\t\t\t}\n\t\t\tquery?: Record<string, unknown>\n\t  }\n\n/**\n * Configuration for clients that determine how APIs are queried.\n */\nexport type BaseClientConfig = {\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike\n}\n\n/**\n * Parameters for any client method that use `fetch()`.\n */\nexport type FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike\n\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * @deprecated Move the `signal` parameter into `fetchOptions.signal`:\n\t *\n\t * @see \\<https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\\>\n\t */\n\tsignal?: AbortSignalLike\n}\n\n/**\n * The result of a `fetch()` job.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype FetchJobResult<TJSON = any> = {\n\tstatus: number\n\theaders: HeadersLike\n\tjson: TJSON\n\ttext?: string\n}\n\nexport abstract class BaseClient {\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike\n\n\tfetchOptions?: RequestInitLike\n\n\t/**\n\t * Active queued `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate queuedFetchJobs: Record<string, LimitFunction> = {}\n\n\t/**\n\t * Active deduped `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate dedupedFetchJobs: Record<\n\t\tstring,\n\t\tMap<AbortSignalLike | undefined, Promise<FetchJobResult>>\n\t> = {}\n\n\tconstructor(options: BaseClientConfig) {\n\t\tthis.fetchOptions = options.fetchOptions\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch as FetchLike\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis)\n\t\t}\n\t}\n\n\tprotected async fetch(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<FetchJobResult> {\n\t\tconst requestInit: RequestInitLike = {\n\t\t\t...this.fetchOptions,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t}\n\n\t\t// Request with a `body` are throttled, others are deduped.\n\t\tif (params.fetchOptions?.body) {\n\t\t\treturn this.queueFetch(url, requestInit)\n\t\t} else {\n\t\t\treturn this.dedupeFetch(url, requestInit)\n\t\t}\n\t}\n\n\tprivate queueFetch(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\t// Rate limiting is done per hostname.\n\t\tconst hostname = new URL(url).hostname\n\n\t\tif (!this.queuedFetchJobs[hostname]) {\n\t\t\tthis.queuedFetchJobs[hostname] = pLimit({\n\t\t\t\tinterval: UNKNOWN_RATE_LIMIT_DELAY,\n\t\t\t})\n\t\t}\n\n\t\treturn this.queuedFetchJobs[hostname](() =>\n\t\t\tthis.createFetchJob(url, requestInit),\n\t\t)\n\t}\n\n\tprivate dedupeFetch(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\tlet job: Promise<FetchJobResult>\n\n\t\t// `fetchJobs` is keyed twice: first by the URL and again by is\n\t\t// signal, if one exists.\n\t\t//\n\t\t// Using two keys allows us to reuse fetch requests for\n\t\t// equivalent URLs, but eject when we detect unique signals.\n\t\tif (\n\t\t\tthis.dedupedFetchJobs[url] &&\n\t\t\tthis.dedupedFetchJobs[url].has(requestInit.signal)\n\t\t) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\tjob = this.dedupedFetchJobs[url].get(requestInit.signal)!\n\t\t} else {\n\t\t\tthis.dedupedFetchJobs[url] = this.dedupedFetchJobs[url] || new Map()\n\n\t\t\tjob = this.createFetchJob(url, requestInit).finally(() => {\n\t\t\t\tthis.dedupedFetchJobs[url]?.delete(requestInit.signal)\n\n\t\t\t\tif (this.dedupedFetchJobs[url]?.size === 0) {\n\t\t\t\t\tdelete this.dedupedFetchJobs[url]\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.dedupedFetchJobs[url].set(requestInit.signal, job)\n\t\t}\n\n\t\treturn job\n\t}\n\n\tprivate createFetchJob(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\treturn this.fetchFn(url, requestInit).then(async (res) => {\n\t\t\t// We can assume Prismic REST API responses\n\t\t\t// will have a `application/json`\n\t\t\t// Content Type. If not, this will\n\t\t\t// throw, signaling an invalid\n\t\t\t// response.\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tlet json: any = undefined\n\t\t\tlet text: string | undefined = undefined\n\t\t\tif (res.ok) {\n\t\t\t\ttry {\n\t\t\t\t\tjson = await res.json()\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\ttext = await res.text()\n\t\t\t\t\tjson = JSON.parse(text)\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstatus: res.status,\n\t\t\t\theaders: res.headers,\n\t\t\t\tjson,\n\t\t\t\ttext,\n\t\t\t}\n\t\t})\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"file":"buildQueryURL.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/buildQueryURL.ts"],"sourcesContent":["import { castArray } from \"./lib/castArray\"\nimport { devMsg } from \"./lib/devMsg\"\n\nimport { version } from \"../package.json\"\n\n/**\n * The query parameter used to indicate if the client is in development mode to\n * the API.\n */\nconst PRISMIC_DEV_PARAM = \"x-d\"\n\n/**\n * The query parameter used to indicate the version of the client to the API.\n */\nconst PRISMIC_CLIENT_VERSION_PARAM = \"x-c\"\n\n/**\n * Create a union of the given object's values, and optionally specify which\n * keys to get the values from.\n *\n * Taken from the `type-fest` package.\n *\n * See:\n * https://github.com/sindresorhus/type-fest/blob/61c35052f09caa23de5eef96d95196375d8ed498/source/value-of.d.ts\n */\ntype ValueOf<\n\tObjectType,\n\tValueType extends keyof ObjectType = keyof ObjectType,\n> = ObjectType[ValueType]\n\n/**\n * An `orderings` parameter that orders the results by the specified field.\n *\n * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n */\nexport interface Ordering {\n\tfield: string\n\tdirection?: \"asc\" | \"desc\"\n}\n\n/**\n * A `routes` parameter that determines how a document's URL field is resolved.\n *\n * {@link https://prismic.io/docs/route-resolver}\n *\n * @example With a document's UID field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:uid\"\n * }\n * ```\n *\n * @example With a Content Relationship `parent` field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:parent?/:uid\",\n * \t\"resolvers\": {\n * \t\t\"parent\": \"parent\"\n * \t}\n * }\n * ```\n */\nexport interface Route {\n\t/**\n\t * The custom type of the document.\n\t */\n\ttype: string\n\n\t/**\n\t * A specific UID to which this route definition is scoped. The route is only\n\t * defined for the document whose UID matches the given UID.\n\t */\n\tuid?: string\n\n\t/**\n\t * A specific language to which this route definition is scoped. The route is\n\t * only defined for documents whose language matches the given language.\n\t */\n\tlang?: string\n\n\t/**\n\t * The resolved path of the document with optional placeholders.\n\t */\n\tpath: string\n\n\t/**\n\t * An object that lists the API IDs of the Content Relationships in the route.\n\t */\n\tresolvers?: Record<string, string>\n}\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://prismic.io/docs/access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#pagesize}\n\t */\n\tpageSize?: number\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#page}\n\t */\n\tpage?: number\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in\n\t * the list.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#after}\n\t */\n\tafter?: string\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetch}\n\t */\n\tfetch?: string | string[]\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetchlinks}\n\t */\n\tfetchLinks?: string | string[]\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content\n\t * Relationships.\n\t *\n\t * {@link https://prismic.io/docs/graphquery-rest-api}\n\t */\n\tgraphQuery?: string\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#lang}\n\t */\n\tlang?: string\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n\t *\n\t * @remarks\n\t * Strings and arrays of strings are deprecated as of\n\t * `@prismicio/client@7.0.0`. Please migrate to the more explicit array of\n\t * objects.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * buildQueryURL(endpoint, {\n\t * \torderings: [\n\t * \t\t{ field: \"my.product.price\", direction: \"desc\" },\n\t * \t\t{ field: \"my.product.title\" },\n\t * \t],\n\t * })\n\t * ```\n\t */\n\t// TODO: Update TSDoc with deprecated API removal in v8\n\torderings?: string | Ordering | (string | Ordering)[]\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is\n\t * resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[]\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: string\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n\t */\n\tref: string\n\n\t/**\n\t * Ref used to populate integration fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/integration-fields}\n\t */\n\tintegrationFieldsRef?: string\n\n\t/**\n\t * One or more filters to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#q}\n\t */\n\tfilters?: string | string[]\n\n\t/**\n\t * @deprecated Renamed to `filters`. Ensure the value is an array of filters,\n\t *   not a single, non-array filter.\n\t */\n\tpredicates?: string | string[]\n}\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string => {\n\t// TODO: Remove the following when `orderings` strings are no longer supported.\n\tif (typeof ordering === \"string\") {\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconst [field, direction] = ordering.split(\" \")\n\n\t\t\tconst objectForm =\n\t\t\t\tdirection === \"desc\"\n\t\t\t\t\t? `{ field: \"${field}\", direction: \"desc\" }`\n\t\t\t\t\t: `{ field: \"${field}\" }`\n\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg(\n\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\treturn ordering\n\t}\n\n\treturn ordering.direction === \"desc\"\n\t\t? `${ordering.field} desc`\n\t\t: ordering.field\n}\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n * {@link https://prismic.io/docs/rest-api-technical-reference}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { filters, predicates, ...params } = args\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`)\n\n\tif (filters) {\n\t\t// TODO: Remove warning when we remove support for string `filters` values.\n\t\tif (process.env.NODE_ENV === \"development\" && !Array.isArray(filters)) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A non-array value was provided to the \\`filters\\` query parameter (\\`${filters}\\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg(\n\t\t\t\t\t\"filters-must-be-an-array\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\t// TODO: Remove `castArray` when we remove support for string `filters` values.\n\t\tfor (const filter of castArray(filters)) {\n\t\t\turl.searchParams.append(\"q\", `[${filter}]`)\n\t\t}\n\t}\n\n\t// TODO: Remove when we remove support for deprecated `predicates` argument.\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`)\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ||\n\t\t\tk) as ValidParamName\n\n\t\tlet value = params[k as keyof typeof params]\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name]\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\t// TODO: Remove the following warning when `orderings` strings are no longer supported.\n\t\t\t\tif (\n\t\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t\ttypeof scopedValue === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\")\n\n\t\t\t\tvalue = `[${v}]`\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]))\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(\n\t\t\t\tname,\n\t\t\t\tcastArray<string | number | Route | Ordering>(value).join(\",\"),\n\t\t\t)\n\t\t}\n\t}\n\n\turl.searchParams.set(PRISMIC_CLIENT_VERSION_PARAM, `js-${version}`)\n\n\tif (process.env.NODE_ENV === \"development\") {\n\t\turl.searchParams.set(PRISMIC_DEV_PARAM, \"1\")\n\t}\n\n\treturn url.toString()\n}\n"],"names":[],"mappings":";;;;;;;;;AASA,MAAM,oBAAoB;AAK1B,MAAM,+BAA+B;AAyOrC,MAAM,iBAAiB;IACtB,aAAa;;AAqBd,MAAM,uBAAuB,CAAC,aAAuC;IAEhE,IAAA,OAAO,aAAa,UAAU;QAC7B,IAAA,QAAQ,IAAI,aAAa,WAAe;YAC3C,MAAM,CAAC,OAAO,SAAS,CAAA,GAAI,SAAS,KAAA,CAAM,GAAG;YAE7C,MAAM,aACL,cAAc,SACX,CAAA,UAAA,EAAa,KAAK,CAAA,sBAAA,CAAA,GAClB,CAAA,UAAA,EAAa,KAAK,CAAA,GAAA,CAAA;YAEtB,QAAQ,IAAA,CACP,CAAA,oJAAA,EAAuJ,UAAU,CAAA,wBAAA,MAA2B,wKAAA,EAC3L,uCAAuC,CACvC,EAAE;QAEL;QAEO,OAAA;IACR;IAEA,OAAO,SAAS,SAAA,KAAc,SAC3B,GAAG,SAAS,KAAK,CAAA,KAAA,CAAA,GACjB,SAAS,KAAA;AACb;AAqBa,MAAA,gBAAgB,CAC5B,UACA,SACW;IACX,MAAM,EAAE,OAAA,EAAS,UAAA,EAAY,GAAG,QAAA,GAAW;IAE3C,MAAM,MAAM,IAAI,IAAI,CAAA,gBAAA,CAAA,EAAoB,GAAG,QAAQ,CAAA,CAAA,CAAG;IAEtD,IAAI,SAAS;QAER,IAAA,QAAQ,IAAI,wCAAa,iBAAiB,CAAC,MAAM,OAAA,CAAQ,OAAO,GAAG;YACtE,QAAQ,IAAA,CACP,CAAA,yFAAA,EAA4F,OAAO,CAAA,2FAAA,MAA8F,wKAAA,EAChM,0BAA0B,CAC1B,EAAE;QAEL;QAGW,KAAA,MAAA,gLAAU,YAAA,EAAU,OAAO,EAAG;YACxC,IAAI,YAAA,CAAa,MAAA,CAAO,KAAK,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,CAAG;QAC3C;IACD;IAGA,IAAI,YAAY;QACJ,KAAA,MAAA,cAAa,iLAAA,EAAU,UAAU,EAAG;YAC9C,IAAI,YAAA,CAAa,MAAA,CAAO,KAAK,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA,CAAG;QAC9C;IACD;IAIA,IAAA,MAAW,KAAK,OAAQ;QACjB,MAAA,OAAQ,cAAA,CAAe,CAAgC,CAAA,IAC5D;QAEG,IAAA,QAAQ,MAAA,CAAO,CAAwB,CAAA;QAE3C,IAAI,SAAS,aAAa;YACnB,MAAA,cAAc,MAAA,CAAO,IAAI,CAAA;YAE/B,IAAI,eAAe,MAAM;gBAExB,IACC,QAAQ,IAAI,wCAAa,iBACzB,OAAO,gBAAgB,UACtB;oBACD,QAAQ,IAAA,CACP,CAAA,8KAAA,GAAiL,2KAAA,EAChL,uCAAuC,CACvC,EAAE;gBAEL;gBAEA,MAAM,0KAAI,YAAA,EAAU,WAAW,EAC7B,GAAA,CAAI,CAAC,WAAa,qBAAqB,QAAQ,CAAC,EAChD,IAAA,CAAK,GAAG;gBAEV,QAAQ,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA,CAAA;YACd;QAAA,OAAA,IACU,SAAS,UAAU;YAC7B,IAAI,OAAO,MAAA,CAAO,IAAI,CAAA,KAAM,UAAU;gBACrC,QAAQ,KAAK,SAAA,uKAAU,YAAA,EAAU,MAAA,CAAO,IAAI,CAAC,CAAC;YAC/C;QACD;QAEA,IAAI,SAAS,MAAM;YACd,IAAA,YAAA,CAAa,GAAA,CAChB,4KACA,YAAA,EAA8C,KAAK,EAAE,IAAA,CAAK,GAAG,CAAC;QAEhE;IACD;IAEA,IAAI,YAAA,CAAa,GAAA,CAAI,8BAA8B,CAAA,GAAA,mKAAM,UAAO,EAAE;IAE9D,IAAA,QAAQ,IAAI,aAAa,WAAe;QACvC,IAAA,YAAA,CAAa,GAAA,CAAI,mBAAmB,GAAG;IAC5C;IAEA,OAAO,IAAI,QAAA;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1124, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1130, "column": 0}, "map": {"version":3,"file":"getRepositoryEndpoint.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/getRepositoryEndpoint.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Get a repository's Prismic Rest API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Rest API V2 endpoint\n *\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAea,MAAA,wBAAwB,CACpC,mBACsD;IAClD,0KAAA,mBAAA,EAAiB,cAAc,GAAG;QACrC,OAAO,CAAA,QAAA,EAAW,cAAc,CAAA,sBAAA,CAAA;IAAA,OAC1B;QACN,MAAM,4KAAI,eAAA,CACT,CAAA,8CAAA,EAAiD,cAAc,EAAA,EAC/D,KAAA,GACA,KAAA,CAAS;IAEX;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1152, "column": 0}, "map": {"version":3,"file":"getRepositoryName.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/getRepositoryName.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\n/**\n * Get a Prismic repository's name from its standard Prismic Document API or\n * GraphQL endpoint.\n *\n * @param repositoryEndpoint - Prismic Document API endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n *\n * @throws {@link Error} Thrown if an invalid Prismic Document API endpoint is\n *   provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\tconst hostname = new URL(repositoryEndpoint).hostname\n\n\t\tif (\n\t\t\thostname.endsWith(\"prismic.io\") || // Production\n\t\t\thostname.endsWith(\"wroom.io\") || // Staging\n\t\t\thostname.endsWith(\"wroom.test\") // Dev\n\t\t) {\n\t\t\treturn hostname.split(\".\")[0]\n\t\t}\n\t} catch {}\n\n\tthrow new PrismicError(\n\t\t`An invalid Prismic Document API endpoint was provided: ${repositoryEndpoint}`,\n\t\tundefined,\n\t\tundefined,\n\t)\n}\n"],"names":[],"mappings":";;;;;AAaa,MAAA,oBAAoB,CAAC,uBAAsC;IACnE,IAAA;QACH,MAAM,WAAW,IAAI,IAAI,kBAAkB,EAAE,QAAA;QAG5C,IAAA,SAAS,QAAA,CAAS,YAAY,KAAA,aAAA;QAC9B,SAAS,QAAA,CAAS,UAAU,KAAA,UAAA;QAC5B,SAAS,QAAA,CAAS,YAAY,GAC7B;YACD,OAAO,SAAS,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA;QAC7B;IAAA,EAAA,OACO,CAAC;IAET,MAAM,4KAAI,eAAA,CACT,CAAA,uDAAA,EAA0D,kBAAkB,EAAA,EAC5E,KAAA,GACA,KAAA,CAAS;AAEX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1170, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1176, "column": 0}, "map": {"version":3,"file":"isRepositoryEndpoint.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/isRepositoryEndpoint.ts"],"sourcesContent":["/**\n * Determines if a string if a Prismic Rest API V2 endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Rest API V2 endpoint, `false`\n *   otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n}\n"],"names":[],"mappings":";;;AASa,MAAA,uBAAuB,CAAC,UAA0B;IAC1D,IAAA;QACH,IAAI,IAAI,KAAK;QAEN,OAAA;IAAA,EAAA,OACA;QACA,OAAA;IACR;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1195, "column": 0}, "map": {"version":3,"file":"Client.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/Client.ts"],"sourcesContent":["import { appendFilters } from \"./lib/appendFilters\"\nimport { castThunk } from \"./lib/castThunk\"\nimport { devMsg } from \"./lib/devMsg\"\nimport { everyTagFilter } from \"./lib/everyTagFilter\"\nimport { findMasterRef } from \"./lib/findMasterRef\"\nimport { findRefByID } from \"./lib/findRefByID\"\nimport { findRefByLabel } from \"./lib/findRefByLabel\"\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\"\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\"\nimport { someTagsFilter } from \"./lib/someTagsFilter\"\nimport { typeFilter } from \"./lib/typeFilter\"\n\nimport type { Query } from \"./types/api/query\"\nimport type { Ref } from \"./types/api/ref\"\nimport type { Form, Repository } from \"./types/api/repository\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport { ForbiddenError } from \"./errors/ForbiddenError\"\nimport { NotFoundError } from \"./errors/NotFoundError\"\nimport { ParsingError } from \"./errors/ParsingError\"\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\"\nimport { PrismicError } from \"./errors/PrismicError\"\nimport { RefExpiredError } from \"./errors/RefExpiredError\"\nimport { RefNotFoundError } from \"./errors/RefNotFoundError\"\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\"\n\nimport type { LinkResolverFunction } from \"./helpers/asLink\"\nimport { asLink } from \"./helpers/asLink\"\n\nimport {\n\ttype AbortSignalLike,\n\tBaseClient,\n\ttype BaseClientConfig,\n\ttype FetchParams,\n\ttype HttpRequestLike,\n} from \"./BaseClient\"\nimport type { BuildQueryURLArgs } from \"./buildQueryURL\"\nimport { buildQueryURL } from \"./buildQueryURL\"\nimport { filter } from \"./filter\"\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nimport { getRepositoryName } from \"./getRepositoryName\"\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500\n\n/**\n * The default number of milliseconds to wait before retrying a rate-limited\n * `fetch()` request (429 response code). The default value is only used if the\n * response does not include a `retry-after` header.\n *\n * The API allows up to 200 requests per second.\n */\nconst DEFUALT_RETRY_AFTER_MS = 1000\n\n/**\n * The maximum number of attemps to retry a query with an invalid ref. We allow\n * multiple attempts since each attempt may use a different (and possibly\n * invalid) ref. Capping the number of attemps prevents infinite loops.\n */\nconst MAX_INVALID_REF_RETRY_ATTEMPS = 3\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID\n\t\t\treleaseID: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel\n\t\t\treleaseLabel: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual\n\t\t\tref: RefStringOrThunk\n\t  }\n)\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>)\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The full Rest API V2 endpoint for the repository. This is only helpful if\n\t * you're using Prismic behind a proxy which we do not recommend.\n\t *\n\t * @defaultValue `getRepositoryEndpoint(repositoryNameOrEndpoint)`\n\t */\n\tdocumentAPIEndpoint?: string\n\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>\n} & BaseClientConfig\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number\n}\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>\n\n\t/**\n\t * A fallback URL if the link resolver does not return a value.\n\t */\n\tdefaultURL: string\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string\n}\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<\n\tTDocuments extends PrismicDocument = PrismicDocument,\n> extends BaseClient {\n\t#repositoryName: string | undefined\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tset repositoryName(value: string) {\n\t\tthis.#repositoryName = value\n\t}\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tget repositoryName(): string {\n\t\tif (!this.#repositoryName) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`A repository name is required for this method but one could not be inferred from the provided API endpoint (\\`${this.documentAPIEndpoint}\\`). To fix this error, provide a repository name when creating the client. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn this.#repositoryName\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tdocumentAPIEndpoint: string\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tset endpoint(value: string) {\n\t\tthis.documentAPIEndpoint = value\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tget endpoint(): string {\n\t\treturn this.documentAPIEndpoint\n\t}\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during\n\t * queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t}\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: Repository | undefined\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as in some Node.js versions, the `fetch` option must be provided as\n\t * part of the `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tsuper(options)\n\n\t\tif (\n\t\t\t(options.documentAPIEndpoint ||\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint)) &&\n\t\t\tprocess.env.NODE_ENV === \"development\"\n\t\t) {\n\t\t\tconst documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint || repositoryNameOrEndpoint\n\n\t\t\t// Matches non-API v2 `.prismic.io` endpoints, see: https://regex101.com/r/xRsavu/1\n\t\t\tif (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(documentAPIEndpoint)) {\n\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst hostname = new URL(documentAPIEndpoint).hostname.toLowerCase()\n\n\t\t\t// Matches non-.cdn `.prismic.io` endpoints\n\t\t\tif (\n\t\t\t\thostname.endsWith(\".prismic.io\") &&\n\t\t\t\t!hostname.endsWith(\".cdn.prismic.io\")\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] The client was created with a non-CDN endpoint. Convert it to the CDN endpoint for better performance. For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Warn if the user provided both a repository endpoint and an `documentAPIEndpoint` and they are different\n\t\t\tif (\n\t\t\t\toptions.documentAPIEndpoint &&\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint) &&\n\t\t\t\trepositoryNameOrEndpoint !== options.documentAPIEndpoint\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] Multiple incompatible endpoints were provided. Create the client using a repository name to prevent this error. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tthis.documentAPIEndpoint = repositoryNameOrEndpoint\n\t\t\ttry {\n\t\t\t\tthis.repositoryName = getRepositoryName(repositoryNameOrEndpoint)\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\\`${repositoryNameOrEndpoint}\\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint ||\n\t\t\t\tgetRepositoryEndpoint(repositoryNameOrEndpoint)\n\t\t\tthis.repositoryName = repositoryNameOrEndpoint\n\t\t}\n\n\t\tthis.accessToken = options.accessToken\n\t\tthis.routes = options.routes\n\t\tthis.brokenRoute = options.brokenRoute\n\t\tthis.defaultParams = options.defaultParams\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref)\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this)\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the\n\t * browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews()\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the\n\t * server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req)\n\t * })\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's\n\t *   cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews()\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst { data } = await this._get<TDocument>(params)\n\n\t\treturn data\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params }\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1\n\t\t}\n\t\tconst { data, url } = await this._get<TDocument>(actualParams)\n\n\t\tconst firstResult = data.results[0]\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult\n\t\t}\n\n\t\tthrow new NotFoundError(\"No documents were returned\", url, undefined)\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by filters such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no filters are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t}\n\n\t\tconst documents: TDocument[] = []\n\t\tlet latestResult: Query<TDocument> | undefined\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page })\n\t\t\tdocuments.push(...latestResult.results)\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY))\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t *\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and\n\t * custom type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom\n\t * Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and\n\t * custom type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific\n\t * custom type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable custom type which\n\t * allows multiple instances of itself.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the singleton custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the custom type, if a matching document\n\t *   exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific custom type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the custom type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom\n\t * Type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the custom type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, typeFilter(documentType)))\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a\n\t * specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(appendFilters(params, someTagsFilter(tag)))\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the\n\t *   tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllBySomeTags([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.documentAPIEndpoint)\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t}\n\n\t\treturn await this.fetch<Repository>(url.toString(), params)\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params)\n\n\t\treturn repository.refs\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByID(refs, id)\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByLabel(refs, label)\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findMasterRef(refs)\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByID(releases, id)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByLabel(releases, label)\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params)\n\n\t\t\tconst url = new URL(tagsForm.action)\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params)\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params)\n\n\t\t\treturn repository.tags\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref || (await this.getResolvedRefString({ signal, fetchOptions }))\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal, fetchOptions }))\n\t\t\t\t.integrationFieldsRef ||\n\t\t\tundefined\n\n\t\treturn buildQueryURL(this.documentAPIEndpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t})\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID\n\t\tlet previewToken: string | undefined | null = args.previewToken\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search)\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string)\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string)\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.refState.httpRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t})\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver })\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future\n\t * queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent()\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query\n\t *   content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t}\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * })\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are\n\t *   supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t *\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository()\n\t\tconst ref = await this.getResolvedRefString()\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t}\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {}\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders]\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t)\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref)\n\n\t\tconst query = url.searchParams.get(\"query\")\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t)\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(params?: FetchParams): Promise<Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL\n\t\t\tthis.cachedRepository = await this.getRepository(params)\n\t\t}\n\n\t\treturn this.cachedRepository\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t *\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\t\tconst form = cachedRepository.forms[name]\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn form\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined\n\n\t\t\tlet cookieJar: string | null | undefined\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\")\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar)\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\n\t\tconst refModeType = this.refState.mode\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)()\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref\n\t}\n\n\t/**\n\t * The private implementation of `this.get`. It returns the API response and\n\t * the URL used to make the request. The URL is sometimes used in the public\n\t * method to include in thrown errors.\n\t *\n\t * This method retries requests that throw `RefNotFoundError` or\n\t * `RefExpiredError`. It contains special logic to retry with the latest\n\t * master ref, provided in the API's error message.\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns An object containing the paginated response containing the result\n\t *   of the query and the URL used to make the API request.\n\t */\n\tprivate async _get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t\tattemptCount = 0,\n\t): Promise<{ data: Query<TDocument>; url: string }> {\n\t\tconst url = await this.buildQueryURL(params)\n\n\t\ttry {\n\t\t\tconst data = await this.fetch<Query<TDocument>>(url, params)\n\n\t\t\treturn { data, url }\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\terror instanceof RefNotFoundError || error instanceof RefExpiredError\n\t\t\t\t) ||\n\t\t\t\tattemptCount >= MAX_INVALID_REF_RETRY_ATTEMPS - 1\n\t\t\t) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\t// If no explicit ref is given (i.e. the master ref from\n\t\t\t// /api/v2 is used), clear the cached repository value.\n\t\t\t// Clearing the cached value prevents other methods from\n\t\t\t// using a known-stale ref.\n\t\t\tif (!params?.ref) {\n\t\t\t\tthis.cachedRepository = undefined\n\t\t\t}\n\n\t\t\tconst masterRef = error.message.match(/Master ref is: (?<ref>.*)$/)\n\t\t\t\t?.groups?.ref\n\t\t\tif (!masterRef) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\tconst badRef = new URL(url).searchParams.get(\"ref\")\n\t\t\tconst issue = error instanceof RefNotFoundError ? \"invalid\" : \"expired\"\n\t\t\tconsole.warn(\n\t\t\t\t`The ref (${badRef}) was ${issue}. Now retrying with the latest master ref (${masterRef}). If you were previewing content, the response will not include draft content.`,\n\t\t\t)\n\n\t\t\treturn await this._get({ ...params, ref: masterRef }, attemptCount + 1)\n\t\t}\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprotected async fetch<T = unknown>(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\tconst res = await super.fetch(url, params)\n\n\t\tif (res.status !== 404 && res.status !== 429 && res.json == null) {\n\t\t\tthrow new PrismicError(undefined, url, res.json || res.text)\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200:\n\t\t\tcase 201: {\n\t\t\t\treturn res.json\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid filter syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tres.json.error || res.json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tres.json,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Incorrect repository name (this response has an empty body)\n\t\t\t// - Ref does not exist\n\t\t\t// - Preview token is expired\n\t\t\tcase 404: {\n\t\t\t\tif (res.json === undefined) {\n\t\t\t\t\tthrow new RepositoryNotFoundError(\n\t\t\t\t\t\t`Prismic repository not found. Check that \"${this.documentAPIEndpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\turl.startsWith(this.documentAPIEndpoint) ? undefined : res.text,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (res.json.type === \"api_notfound_error\") {\n\t\t\t\t\tthrow new RefNotFoundError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tres.json.type === \"api_security_error\" &&\n\t\t\t\t\t/preview token.*expired/i.test(res.json.message)\n\t\t\t\t) {\n\t\t\t\t\tthrow new PreviewTokenExpiredError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tthrow new NotFoundError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Gone\n\t\t\t// - Ref is expired\n\t\t\tcase 410: {\n\t\t\t\tthrow new RefExpiredError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Too Many Requests\n\t\t\t// - Exceeded the maximum number of requests per second\n\t\t\tcase 429: {\n\t\t\t\tconst parsedRetryAfter = Number(res.headers.get(\"retry-after\"))\n\t\t\t\tconst delay = Number.isNaN(parsedRetryAfter)\n\t\t\t\t\t? DEFUALT_RETRY_AFTER_MS\n\t\t\t\t\t: parsedRetryAfter\n\n\t\t\t\treturn await new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(await this.fetch(url, params))\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, res.json)\n\t}\n}\n"],"names":["RefStateMode"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2449, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2455, "column": 0}, "map": {"version":3,"file":"createClient.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/src/createClient.ts"],"sourcesContent":["import type { PrismicDocument } from \"./types/value/document\"\n\nimport type { ClientConfig } from \"./Client\"\nimport { Client } from \"./Client\"\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\")\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\")\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <TDocuments extends PrismicDocument>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options)\n"],"names":[],"mappings":";;;;;AAqCO,MAAM,eAA6B,CACzC,0BACA,UACI,4JAAI,SAAA,CAAmB,0BAA0B,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2463, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2479, "column": 0}, "map": {"version":3,"file":"enableAutoPreviews.js","sources":["file:///Users/nikolasnemergut/Desktop/Websites/lunascope-cms/node_modules/%40prismicio/next/src/enableAutoPreviews.ts"],"sourcesContent":["import { type Client, cookie as prismicCookie } from \"@prismicio/client\";\n\n/** Configuration for `enableAutoPreviews`. */\nexport type EnableAutoPreviewsConfig = {\n\t/** Prismic client with which automatic previews will be enabled. */\n\t// `Pick` is used to use the smallest possible subset of\n\t// `prismic.Client`. Doing this reduces the surface area for breaking\n\t// type changes.\n\tclient: Pick<Client, \"queryContentFromRef\" | \"enableAutoPreviewsFromReq\">;\n};\n\n/**\n * Configures a Prismic client to automatically query draft content during a\n * preview session.\n *\n * @param config - Configuration for the function.\n */\nexport function enableAutoPreviews(config: EnableAutoPreviewsConfig): void {\n\t// We use a function value so the cookie is checked on every\n\t// request. We don't have a static value to read from.\n\tconfig.client.queryContentFromRef(async () => {\n\t\t// Need this to avoid the following Next.js build-time error:\n\t\t// You're importing a component that needs next/headers. That only works\n\t\t// in a Server Component which is not supported in the pages/ directory.\n\t\tconst { cookies, draftMode } = await import(\"next/headers\");\n\n\t\tlet isDraftModeEnabled = false;\n\t\ttry {\n\t\t\tisDraftModeEnabled = (await draftMode()).isEnabled;\n\t\t} catch {\n\t\t\t// `draftMode()` may have been called in a palce that\n\t\t\t// does not have access to its async storage. This\n\t\t\t// occurs in places like `generateStaticParams()`. We\n\t\t\t// can ignore this case.\n\t\t\treturn;\n\t\t}\n\t\tif (!isDraftModeEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cookie = (await cookies()).get(prismicCookie.preview)?.value;\n\t\tif (!cookie) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isActiveCookie = cookie.includes(\"websitePreviewId=\");\n\t\tif (!isActiveCookie) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn cookie;\n\t});\n}\n"],"names":["cookie","prismicCookie"],"mappings":";;;;;AAiBM,SAAU,mBAAmB,MAAA,EAAgC;IAG3D,OAAA,MAAA,CAAO,mBAAA,CAAoB,YAAW;;QAI5C,MAAM,EAAE,OAAA,EAAS,SAAA,EAAA,GAAc,MAAM,OAAO,cAAc;QAE1D,IAAI,qBAAqB;QACrB,IAAA;YACmB,qBAAA,CAAA,MAAM,WAAA,EAAa,SAAA;QAAA,EAAA,OAClC;YAKP;QAAA;QAED,IAAI,CAAC,oBAAoB;YACxB;QAAA;QAGD,MAAMA,WAAAA,CAAU,KAAA,CAAA,MAAM,QAAA,CAAA,EAAW,GAAA,2LAAIC,SAAAA,CAAc,OAAO,CAAA,KAA1C,OAAA,KAAA,IAAA,GAA6C,KAAA;QAC7D,IAAI,CAACD,UAAQ;YACZ;QAAA;QAGK,MAAA,iBAAiBA,SAAO,QAAA,CAAS,mBAAmB;QAC1D,IAAI,CAAC,gBAAgB;YACpB;QAAA;QAGM,OAAAA;IAAA,CACP;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2510, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}